participant "client" as Client
participant "server" as Server

bottomparticipants

entryspacing 1.0
note over Client:client:\n• supports mTLS authentication with X.509 certificates\n• uses a self-signed or CA-signed certificate with a certificate extension containing a custom OID and\n   ASN1:UTF8String value that serves as a global client identifier in respect of the service it represents,\n   e.g., 1.2.3.4.5.6.7.8=ASN1:UTF8String:client._mhs._grip.foo.com\n• the client's public key fingerprint is published on the client domain using DNS TXT record,\n   e.g., client._mhs._grip.foo.com IN TXT  "v=grip1; h=sha256; p=d2abde240d7cd3ee6b ... e971"
note over Server:server:\n• supports mTLS authentication with X.509 certificates\n• uses a CA-signed certificate with an appropriate Subject Alternative Name (SAN)\n• uses a DNS SRV record to specify a host and port of the server, while identifies the respective\n   service, e.g., _mhs._tcp.bar.com\n• uses the information in the assertion to identify the user and makes authorization decisions\n   using a placeholder message that servers as an access control list
Client->Client:1. The client generates a token — a signed, using the client's private key,\n    DNS-bound assertion in JWT format with these claims:\n    {iss, aud, sub, exp, nbf, jwk, act{sub}, tokens}\n    • iss identifies who issues the token — CN from public client's certificate,\n       e.g., foo.com\n    • aud identifies the target service by the DNS SRV record, e.g., _mhs._tcp.bar.com\n    • sub identifies the user by email address,\n       e.g., User Principal Name (UPN) from Active Directory (AD)\n       (client impersonates the user by using their email address)\n    • exp, nbf are the standard JWT claims\n    • jwks holds a client's certificate public key in the JWK Set format\n       (alternatively provide JWK Set by URI using jwks_uri claim)\n    • tokens (optional) holds an embedded JWT from the previous hop\n    • digest contains a digest (cryptographic hash) of the data being transmitted (pushed or pulled),\n       e.g., a pushed RFC5322 message or a pulled message external body (blob or file)
Client->Server:2. Send an HTTPS request to the server with the token using mTLS
Server->Server:3. Pre-data transmission authorization decision\n    • the client is authenticated via the DNS using the TXT record and the custom OID value\n       from the public client's certificate\n    • verify the token signature\n    • validate proof-of-possession\n    • verify the aud claim\n    • (optional) evaluate embedded tokens\n    • the domain part of the author's email address or one of the recipient's email addresses\n       listed in the placeholder message and the domain part of the custom OID value from\n       the public client's certificate must match\n    • check that the user's email address is listed in the placeholder message\n    • (applicable to pull data methods) verify the digest claim value of the embedded tokens\n       against the digest of the data being transmitted (pulled)
Server->Server:4. Post-data transmission authorization decision (applicable to push data methods)\n    • verify the digest claim value of the embedded tokens against digest of transmitted\n       (pushed) data
Server->Client:5. Return the HTTP response, typically with 200, 201 status code
